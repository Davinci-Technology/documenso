# ============================================================================
# SECRETS TEMPLATE - DO NOT COMMIT REAL VALUES!
# ============================================================================
#
# This file is a TEMPLATE ONLY for documentation purposes.
# Real secrets are managed via Jenkins during deployment.
#
# ============================================================================
# Required Jenkins Credentials
# ============================================================================
#
# Create these in Jenkins at: ci.davincisolutions.ai/credentials/
#
# | Credential ID                    | Type        | Description                      |
# |----------------------------------|-------------|----------------------------------|
# | davinci-sign-nextauth-secret     | Secret text | openssl rand -hex 32             |
# | davinci-sign-encryption-key      | Secret text | openssl rand -hex 32             |
# | davinci-sign-encryption-key-2    | Secret text | openssl rand -hex 32             |
# | davinci-sign-postgres-password   | Secret text | Azure PostgreSQL password        |
# | davinci-sign-minio-password      | Secret text | MinIO root password              |
# | davinci-sign-smtp-password       | Secret text | SendGrid API key                 |
# | davinci-sign-cert-passphrase     | Secret text | Signing certificate passphrase   |
# | davinci-sign-certificate-p12     | Secret file | The .p12 certificate file        |
#
# ============================================================================
# Manual Secret Creation (for testing/debugging)
# ============================================================================
#
# To create secrets manually via kubectl:
#
# # Generate encryption keys
# NEXTAUTH_SECRET=$(openssl rand -hex 32)
# ENCRYPTION_KEY=$(openssl rand -hex 32)
# ENCRYPTION_KEY_2=$(openssl rand -hex 32)
#
# # Create main secrets
# kubectl create secret generic davinci-sign-secrets \
#   --namespace=davinci-sign-production \
#   --from-literal=NEXTAUTH_SECRET="${NEXTAUTH_SECRET}" \
#   --from-literal=NEXT_PRIVATE_ENCRYPTION_KEY="${ENCRYPTION_KEY}" \
#   --from-literal=NEXT_PRIVATE_ENCRYPTION_SECONDARY_KEY="${ENCRYPTION_KEY_2}" \
#   --from-literal=POSTGRES_PASSWORD="<your-postgres-password>" \
#   --from-literal=MINIO_ROOT_PASSWORD="<your-minio-password>" \
#   --from-literal=NEXT_PRIVATE_UPLOAD_SECRET_ACCESS_KEY="<same-as-minio-password>" \
#   --from-literal=NEXT_PRIVATE_SMTP_PASSWORD="<sendgrid-api-key>" \
#   --from-literal=NEXT_PRIVATE_SIGNING_PASSPHRASE="<cert-passphrase>"
#
# # Create certificate secret
# kubectl create secret generic davinci-sign-certificate \
#   --namespace=davinci-sign-production \
#   --from-file=cert.p12=/path/to/your/cert.p12
#
# ============================================================================
# Secret Rotation
# ============================================================================
#
# To rotate secrets:
# 1. Update credential in Jenkins
# 2. Trigger a new build (this will re-apply secrets)
# 3. Rolling restart will pick up new values
#
# To rotate manually:
# kubectl create secret generic davinci-sign-secrets \
#   ... (same command as above with new values) ...
#   --dry-run=client -o yaml | kubectl apply -f -
#
# kubectl rollout restart deployment/davinci-sign -n davinci-sign-production
#
# ============================================================================

# This is an empty placeholder - secrets are created by Jenkins pipeline
apiVersion: v1
kind: Secret
metadata:
  name: davinci-sign-secrets
  namespace: davinci-sign-production
  labels:
    app: davinci-sign
    environment: production
type: Opaque
data: {}
---
apiVersion: v1
kind: Secret
metadata:
  name: davinci-sign-certificate
  namespace: davinci-sign-production
  labels:
    app: davinci-sign
    environment: production
type: Opaque
data: {}
